"""Class for using AND-(X)OR trees to define the space of possible actions that an agent has available"""

import copy
from xml.dom.minidom import *
from PsychActions import *

class DecisionSpace:
    """Space of possible options that an agent may have
    Each option is assumed to be a dictionary-type object.  A L{DecisionSpace} object generates all of the possible objects that can be generated by extending a given base (partially filled) object with a given key, whose value ranges over a supplied list of possible fillers.
    @ivar base: the kernel dictionary object about which all the options are convolved
    @ivar values: the possible options that can be used at this level of the decision hierarchy
    @cvar branchType: label for this class of L{DecisionSpace}
    @type branchType: string
    @ivar illegal: options that should never be considered
    @type illegal: strS{->}L{Action}
    """

    branchType = None
    
    def __init__(self,key=None,values=[],base=None):
        """Constructor that initializes the base option and relevant key
        @param key: the dictionary key over which this decision space generates possible fillers
        @type key: string
        @param base: the original dictionary object that is to be filled in (by default, a list containing a single empty L{Action} object)
        """
        self.key = key
        if base:
            self.base = base
        else:
            self.base = [Action()]
        self.values = values[:]
        self.options = []
        self.illegal = {}
        # Directly specified options
        self.extras = []
        self._generated = False

    def directAdd(self,option):
        """Adds the given option directly to the space
        @param option: the option to add to the space
        @type option: C{L{Action}[]}
        """
        if not option in self.extras:
            self.extras.append(option)

    def setIllegal(self,option):
        """Removes the specified option from consideration
        @type option: L{Action}[]
        """
        self.illegal[str(option)] = option
        self._generated = False

    def isIllegal(self,option):
        """
        @type option: L{Action}[]
        @return: C{True} iff the given option is considered illegal
        @rtype: bool"""
        return self.illegal.has_key(str(option))

    def append(self,value):
        """Adds the given value to the list of possible fillers
        @type value: C{str}
        """
        if not value in self.values:
            if isinstance(value,Action):
                raise TypeError
            self.values.append(value)
            self._generated = False

    def remove(self,value):
        """Removes the given value from the list of possible fillers
        @return: false if the value is not present; otherwise, true"""
        try:
            self.values.remove(value)
            self._generated = False
            return True
        except ValueError:
            # Raise exception?  For now, no
            return False

    def replace(self,old,new):
        """Replaces single old value with new values
        @param old: a single value
        @param new: a list of values

        The method continues the replacement by descending recursively
        if there are any nested decision spaces""" 
        if self.remove(old):
            for value in new:
                self.append(value)
        if isinstance(self.base,DecisionSpace):
            # Descend recursively and continue replacing
            self.base.replace(old,new)
            
    def getOptions(self):
        """Accessor for the options in this space
        @return:  a list of possible options (typically, L{Action} instances)
        """
        if not self._generated:
            self.generateOptions()
        return self.options+self.extras

    def testForField(self,field='actor'):
        """Debugging method that returns true iff the given field is set"""
        for action in self.getOptions():
            if isinstance(action,list):
                actionList = action
            else:
                actionList = [action]
            for action in actionList:
                if action[field]:
                    return 1
        else:
            return None
        
    def generateOptions(self):
        """Utility method that generates possible options"""
        self.options = []
        self._generated = True

    def __str__(self):
        content = '%s: (%s)' % (self.key,self.branchType)
        valueStr = ''
        for value in self.values:
            valueStr += '\n->'
            if isinstance(value,dict):
                value = value['value']
            valueStr += str(value).replace('\n','\n\t')
        content += '%s\n' % (valueStr)
        content += str(self.base).replace('\n','\n\t')
        return content
    
    def __copy__(self):
        space = self.__class__(self.key,self.values,self.base)
        space.extras = self.extras[:]
        return space

    def __deepcopy(self):
        space = self.__class__(self.key,self.values,
                               copy.deepcopy(self.base))
        space.extras = copy.deepcopy(self.extras)
        return space

    def __xml__(self):
        doc = Document()
        root = doc.createElement('decisions')
        doc.appendChild(root)
        if self.branchType:
            if self.branchType:
                root.setAttribute('branch',self.branchType)
            if self.key:
                root.setAttribute('key',self.key)
        # Append the values
        node = doc.createElement('values')
        root.appendChild(node)
        for option in self.values:
            subNode = doc.createElement('value')
            if isinstance(option,str):
                # Instantiated action
                subNode.setAttribute('value',option)
                subNode.setAttribute('type','literal')
            elif isinstance(option,dict):
                if isinstance(option['value'],DecisionSpace):
                    subNode.appendChild(option['value'].__xml__().documentElement)
                else:
                    # Generic action spec
                    subNode.setAttribute('type',option['type'])
                    subNode.setAttribute('value',option['value'])
            else:
                subNode.appendChild(option.__xml__().documentElement)
            node.appendChild(subNode)
        # Append the base decision
        node = doc.createElement('base')
        root.appendChild(node)
        if isinstance(self.base,DecisionSpace):
            node.appendChild(self.base.__xml__().documentElement)
        else:
            for option in self.base:
                node.appendChild(option.__xml__().documentElement)
        # Append any leftover options
        for option in self.extras:
            node = doc.createElement('option')
            root.appendChild(node)
            for action in option:
                node.appendChild(action.__xml__().documentElement)
        # Append any illegal options
        for option in self.illegal.values():
            node = doc.createElement('illegal')
            root.appendChild(node)
            for action in option:
                node.appendChild(action.__xml__().documentElement)
        return doc

    def parse(self,element):
        assert(element.tagName == 'decisions')
        self.key = str(element.getAttribute('key'))
        if len(self.key) == 0:
            self.key = None
        child = element.firstChild
        while child:
            if child.nodeType == Node.ELEMENT_NODE:
                if child.tagName == 'option':
                    actionList = []
                    subChild = child.firstChild
                    while subChild:
                        if subChild.nodeType == subChild.ELEMENT_NODE:
                            act = Action()
                            act.parse(subChild)
                            actionList.append(act)
                        subChild = subChild.nextSibling
                    self.directAdd(actionList)
                elif child.tagName == 'illegal':
                    actionList = []
                    subChild = child.firstChild
                    while subChild:
                        if subChild.nodeType == subChild.ELEMENT_NODE:
                            act = Action()
                            act.parse(subChild)
                            actionList.append(act)
                        subChild = subChild.nextSibling
                    self.setIllegal(actionList)
                elif child.tagName == 'values':
                    subChild = child.firstChild
                    while subChild:
                        if subChild.nodeType == subChild.ELEMENT_NODE:
                            if subChild.hasAttribute('type'):
                                # Generic action spec
                                value = {'type':str(subChild.getAttribute('type')),
                                         'value':str(subChild.getAttribute('value')),
                                         }
                            elif subChild.hasAttribute('value'):
                                # Instantiated action
                                value = str(subChild.getAttribute('value'))
                            else:
                                # Subspace
                                grandChild = subChild.firstChild
                                while grandChild and \
                                      grandChild.nodeType != Node.ELEMENT_NODE:
                                    grandChild = grandChild.nextSibling
                                value = parseSpace(grandChild)
                            self.values.append(value)
                        subChild = subChild.nextSibling
                elif child.tagName == 'base':
                    subChild = child.firstChild
                    while subChild and subChild.nodeType != Node.ELEMENT_NODE:
                        subChild = subChild.nextSibling
                    if not subChild:
                        self.base = []
                    elif subChild.tagName == 'decisions':
                        self.base = parseSpace(subChild)
                    else:
                        self.base = []
                        while subChild:
                            if subChild.nodeType == Node.ELEMENT_NODE:
                                act = Action()
                                act.parse(subChild)
                                self.base.append(act)
                            subChild = subChild.nextSibling
            child = child.nextSibling
        
class ORSpace(DecisionSpace):
    """Space of possible options expressed as a disjunction of all possible values

    The options generated are a disjunction over the the decision spaces in the L{values} attribute.
    @warning: Assumes that the L{values} attribute contains a list of L{DecisionSpace} instances
    @note: Ignores the L{base} attribute

    >>> space = {'type':'OR','values':[{'type':'decision','value':decisions1},{'type':'decision','value':decisions2},...,{'type':'decision','value':'decisionsn}]}

    The resulting space will have the union of actions across the decision spaces, C{decisions1} to C{decisionsn}.  Keep in mind that duplicates will be included!
    """
    branchType = 'OR'

    def generateOptions(self):
        """Utility method that generates possible options (OR assumed)
        @note: no duplicates returned
        """
        options = {}
        self.options = []
        for value in self.values:
            if isinstance(value,dict):
                value = value['value']
            if isinstance(value,DecisionSpace):
                for option in value.getOptions():
                    key = str(option)
                    if not options.has_key(key):
                        options[key] = True
                        self.options.append(option)
        self._generated = True
        
class XORSpace(DecisionSpace):
    """Space of possible options expressed as XOR tree"""
    
    branchType = 'XOR'
            
    def generateOptions(self):
        """Utility method that generates possible options (XOR assumed)"""
        self.options = []
        for value in self.values:
            if isinstance(self.base,DecisionSpace):
                # Nested decision space
                options = self.base.getOptions()
                for option in options:
                    newOption = []
                    for item in option:
                        newItem = copy.copy(item)
                        if isinstance(value,dict):
                            newItem[self.key] = value['value']
                        else:
                            newItem[self.key] = value
                        newOption.append(newItem)
                    self.options.append(newOption)
            else:
                # Assume list
                option = []
                for item in self.base:
                    newItem = copy.copy(item)
                    if isinstance(value,dict):
                        newItem[self.key] = value['value']
                    else:
                        newItem[self.key] = value
                    option.append(newItem)
                self.options.append(option)
        self._generated = True
            
class AndSpace(DecisionSpace):
    """Space of possible options expressed as AND tree"""
    
    branchType = 'AND'

    def generateOptions(self):
        """Utility method that generates possible options (AND assumed)"""
        self.options = self.__generateAndOptions(self.values,
                                                self.base.getOptions())
        self._generated = True

    def __generateAndOptions(self,values,baseOptions,result=[[]]):
        """Utility method that composes AND options with suboptions"""
        try:
            value = values[0]
        except IndexError:
            return result
        newResult = []
        if isinstance(value,DecisionSpace):
            for newOption in value.getOptions():
                for option in result:
                    newItem = copy.copy(option)
                    newItem.append(newOption)
                    newResult.append(newItem)
        else:
            for option in result:
                for base in baseOptions:
                    newOption = copy.copy(option)
                    for item in base:
                        newItem = copy.copy(item)
                        if isinstance(value,dict):
                            newItem[self.key] = value['value']
                        else:
                            newItem[self.key] = value
                        newOption.append(newItem)
                    newResult.append(newOption)
        return self.__generateAndOptions(values[1:],baseOptions,newResult)

_spacesByType = {
    None: DecisionSpace,
    'XOR': XORSpace,
    'AND': AndSpace,
    'OR': ORSpace,
    }

def parseSpace(element):
    """Extracts a L{DecisionSpace} instance from an XML specification.  In reality, this just identifies the correct L{DecisionSpace} subclass and then invokes the appropriate I{parse} method
    @param element: XML element (i.e., <decisions ...>...)
    @return: L{DecisionSpace}
    """
    branchType = str(element.getAttribute('branch'))
    try:
        cls = _spacesByType[string.upper(branchType)]
    except KeyError:
        cls = DecisionSpace
    space = cls()
    space.parse(element)
    return space

def extractSpace(spec):
    """Returns a L{DecisionSpace} object from the given dictionary specification

    @param spec: The dictionary should be structured as follows:
       - I{type}: either C{None}, 'XOR', 'OR', or 'AND',
       - I{base}:   a dictionary specification of a L{DecisionSpace} object (optional)
       - I{key}:    key argument used for constructor (defaults to C{None})
       - I{values}: values argument use for constructor (optional)
    @return: The L{DecisionSpace} object represented by the spec
    @rtype: L{DecisionSpace}
    """
    if spec['type'] == 'action':
        # A single action
        action = Action(spec['values'][0])
        subspace = DecisionSpace(base=[action])
        return subspace
    if spec.has_key('base'):
        base = extractSpace(spec['base'])
    else:
        base = None
    try:
        values = spec['values']
    except KeyError:
        values = []
    for value in values:
        if value['type'] == 'decision':
            value['value'] = extractSpace(value['value'])
    try:
        key = spec['key']
    except KeyError:
        key = None
    if base:
        return _spacesByType[spec['type']](key,values,base)
    else:
        return _spacesByType[spec['type']](key,values)

if __name__ == '__main__':
    subSpace = XORSpace('type',[{'type':'literal',
                                 'value':'hold'},
                                {'type':'literal',
                                 'value':'inspect'},
                                {'type':'literal',
                                 'value':'pass'}])
    print subSpace.getOptions()
    space = AndSpace('object',['shipperA','shipperB'],subSpace)
    print space.getOptions()

    doc = space.__xml__()
    space = XORSpace()
    space.parse(doc.documentElement)
    print 'XML_----------------------'
    print space.getOptions()
    print 'XML_----------------------'
    parsedDict = {'type':'XOR',
                  'key':'object',
                  'values':[{'type':'generic',
                             'value':'Shipper'}],
                  'base':{'type':'XOR',
                          'key':'type',
                          'values':[{'type':'literal',
                                     'value':'hold'},
                                    {'type':'literal',
                                     'value':'inspect'},
                                    {'type':'literal',
                                     'value':'pass'}]}}
    parsedSpace = extractSpace(parsedDict)
    print parsedSpace.getOptions()
##    print parsedSpace
    customerDict = {'type':'XOR',
                    'key':'object',
                    'values': [{'type':'generic','value':'Shipper'}],
                    'base':{'type':'action',
                            'values':[{'type':'shipThrough'}],
                            }
                    }
    customerSpace = extractSpace(customerDict)
    print customerSpace.getOptions()
##    print customerSpace

    space = extractSpace({'type':'OR',
                          'values':[{'type':'decision','value':parsedDict},
                                    {'type':'decision','value':customerDict},
                                    ],
                          })
    print space.getOptions()

    space = parseSpace(space.__xml__().documentElement)
    print space.getOptions()
